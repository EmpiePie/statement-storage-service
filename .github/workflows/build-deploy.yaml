name: Java Container Workflow

on:
  workflow_dispatch:
  pull_request:
    branches:
      - develop
      - release
      - main
    types:
      - opened
      - closed
    paths:
      - 'src/**'
      - 'aql/**'
      - 'certs/**'
      - 'Dockerfile'
      - 'pom.xml'
      - '.github/workflows/*.yaml'

permissions:
  id-token: write
  contents: write
  pull-requests: write

concurrency:
  group: ${{ github.event_name == 'pull_request' && github.base_ref || github.ref_name }}
  cancel-in-progress: false

env:
  SDLC: ${{ github.event_name == 'pull_request' && github.base_ref || github.ref_name }}
  JF_URL: ${{ vars.JF_URL }}
  BASE_URL: ${{ vars.JF_BASE_URL }}
  JF_PROJECT_KEY: ${{ vars.JF_PROJECT_KEY }}
  DOCKER_REPO: ${{ vars.DOCKER_REPO }}
  JF_REPO: ${{ vars.JF_REPO }}
  RUN: ${{ github.run_number }}

jobs:
  build:
    name: Build Application
    runs-on:
      - arc-odin
    container:
      image: artifacts.capitecbank.co.za/universal/maven:3-amazoncorretto-21-al2023
      credentials:
        username: ${{ vars.JF_ACCESS_USER }}
        password: ${{ secrets.JF_ACCESS_TOKEN }}
    outputs:
      POM_VERSION: ${{ steps.variables.outputs.POM_VERSION }}
      POM_GROUP_ID: ${{ steps.variables.outputs.POM_GROUP_ID }}
      POM_ARTIFACT_ID: ${{ steps.variables.outputs.POM_ARTIFACT_ID }}
      POM_ARTIFACT_PATH: ${{ steps.variables.outputs.POM_ARTIFACT_PATH }}
    steps:
      - name: Install JFrog
        id: install-jf
        uses: jfrog/setup-jfrog-cli@v3
        env:
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
        # with:
        #   version: latest
        #   download-repository: odin-jfrog-cli-remote
      - name: Ping JFrog
        run: jf rt ping

      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: JFrog Config Java Application
        id: config-jf
        run: |
          jf mvn-config --repo-resolve-releases $JF_REPO --repo-resolve-snapshots $JF_REPO --repo-deploy-releases $JF_REPO --repo-deploy-snapshots $JF_REPO

      - name: Set Variables
        id: variables
        run: |
          echo "POM_ARTIFACT_ID=$(mvn help:evaluate -Dexpression=project.artifactId -q -DforceStdout)" >> "${GITHUB_OUTPUT}"
          echo "POM_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)" >> "${GITHUB_OUTPUT}"
          echo "POM_GROUP_ID=$(mvn help:evaluate -Dexpression=project.groupId -q -DforceStdout)" >> "${GITHUB_OUTPUT}"
          echo "POM_ARTIFACT_PATH=$(mvn help:evaluate -Dexpression=project.groupId -q -DforceStdout | tr '.' '/')" >> "${GITHUB_OUTPUT}"
          echo
          echo "Variables:"
          echo "--------------------------------"
          cat ${GITHUB_OUTPUT}
          echo "--------------------------------"
          echo "FULL SHA: ${GITHUB_SHA}"
          echo "SHORT SHA: ${GITHUB_SHA::8}"
          echo "RUN: $RUN"
          echo "--------------------------------"

      - name: Build Java Application
        id: run-jf
        env:
          BUILD_NAME: ${{ steps.variables.outputs.POM_ARTIFACT_ID }}
        run: |
          jf mvn clean install --quiet --batch-mode --errors --show-version --project $JF_PROJECT_KEY --threads 8 --build-name $BUILD_NAME --build-number $RUN

  container:
    name: Build Container
    needs:
      - build
    runs-on:
      - self-hosted
      - m6i-xlarge
      - ubuntu-22
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && (github.event.action == 'closed' && (github.base_ref == 'develop' || github.base_ref == 'release') && github.event.pull_request.merged == true)) }}
    env:
      POM_VERSION: ${{ needs.build.outputs.POM_VERSION }}
      POM_ARTIFACT_ID: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
      POM_ARTIFACT_PATH: ${{ needs.build.outputs.POM_ARTIFACT_PATH }}
      BUILD_NAME: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
    outputs:
      IMAGE: ${{ steps.docker-build.outputs.IMAGE }}
    steps:
      - name: Install JFrog
        id: install-jf
        uses: jfrog/setup-jfrog-cli@v3
        env:
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
          # with:
          #   version: latest
          #   download-repository: odin-jfrog-cli-remote
      - name: Ping JFrog
        run: jf rt ping

      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: Download Artifact
        id: jf-download-artifact
        run: jf rt download "${JF_REPO}/${POM_ARTIFACT_PATH}/${POM_ARTIFACT_ID}/${POM_VERSION}/*.jar" target/${POM_ARTIFACT_ID}-${POM_VERSION}.jar --sort-by=created --sort-order=desc --limit=1 --flat=true --project $JF_PROJECT_KEY --build-number $RUN --build-name $BUILD_NAME

      - name: Login to JFrog Edge Cache Docker Registry
        id: edge-cache-docker-login
        uses: docker/login-action@v2
        with:
          registry: ${{ vars.JF_EDGE_BASE_URL }}
          username: ${{ vars.JF_ACCESS_USER }}
          password: ${{ secrets.JF_ACCESS_TOKEN }}

      - name: Docker Build
        id: docker-build
        env:
          JAR_FILE: ${{ env.POM_ARTIFACT_ID }}-${{ env.POM_VERSION }}.jar
        run: |
          IMAGE=${BASE_URL}/${DOCKER_REPO}/${POM_ARTIFACT_ID}:${POM_VERSION}-${GITHUB_SHA::8}
          docker build -f Dockerfile --build-arg JAR_FILE=$JAR_FILE --iidfile=image-sha.txt -t $IMAGE .
          IMAGEFILE="${IMAGE}@$(cat image-sha.txt)"
          touch image-file.txt
          echo
          echo $IMAGEFILE >> image-file.txt
          echo 
          echo "--------------------------------"
          cat image-file.txt
          echo "--------------------------------"
          echo "IMAGE=${IMAGE}" >> "${GITHUB_OUTPUT}"

      - name: Login to JFrog Docker Registry
        id: docker-login
        uses: docker/login-action@v2
        with:
          registry: ${{ env.JF_URL }}
          username: ${{ vars.JF_ACCESS_USER }}
          password: ${{ secrets.JF_ACCESS_TOKEN }}

      - name: JFrog Docker Push
        id: docker-push
        run: jf docker push ${BASE_URL}/${DOCKER_REPO}/${POM_ARTIFACT_ID}:${POM_VERSION}-${GITHUB_SHA::8} --build-name $POM_ARTIFACT_ID --project $JF_PROJECT_KEY --build-number $RUN

      - name: JFrog Publish Docker Build Info
        id: jf-docker-build-info
        run: jf rt build-publish $BUILD_NAME $RUN --project $JF_PROJECT_KEY

  deploy-dev:
    name: Update DEV deployment version
    needs:
      - build
      - container
    runs-on:
      - ubuntu-22.04
    environment: dev
    if: ${{ (github.event_name == 'workflow_dispatch') || (github.event.pull_request.merged == true && github.base_ref == ('develop')) }}
    env:
      POM_VERSION: ${{ needs.build.outputs.POM_VERSION }}
      POM_ARTIFACT_ID: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
      BUILD_NAME: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
    steps:
      - name: Print Docker Image URI
        id: docker-image-uri
        run: |
          echo "image: ${{ needs.container.outputs.IMAGE }}"

      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: Deploy via Argo to DEV
        id: argo-deploy
        uses: capitec-odin/action-deploy@v7
        with:
          repository: ${{ vars.GITOPS_REPO}}
          access-token: ${{ secrets.GITOPS_TOKEN }}
          component: ${{ vars.GITOPS_COMPONENT_NAME }}
          image: '${{ needs.container.outputs.IMAGE }}'
          org: ${{ vars.GITOPS_ORG }}
          enviro: dev
          jf-access-user: ${{vars.JF_ACCESS_USER}}          
          jf-access-token: ${{secrets.JF_ACCESS_TOKEN}}
          jf-project-key: ${{vars.JF_PROJECT_KEY}}

      # - name: Install JFrog
      #   id: install-jfrog
      #   uses: jfrog/setup-jfrog-cli@v3
      #   env:
      #     JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
      #     # with:
      #     #   version: latest
      #     #   download-repository: odin-jfrog-cli-remote
      # - name: Ping JFrog
      #   run: jf rt ping

      # # - name: JFrog Promote Build to DEV
      # #   id: promote-docker
      # #   run: jf rt build-promote $BUILD_NAME $RUN $DOCKER_REPO --project $JF_PROJECT_KEY --status DEV

  deploy-int:
    name: Update INT deployment version
    needs:
      - build
      - container
    runs-on:
      - ubuntu-22.04
    if: ${{ (github.event_name == 'workflow_dispatch') || (github.event.pull_request.merged == true && github.base_ref == ('develop')) }}
    environment: int
    env:
      POM_VERSION: ${{ needs.build.outputs.POM_VERSION }}
      POM_ARTIFACT_ID: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
      BUILD_NAME: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
    steps:
      - name: Print Docker Image URI
        id: docker-image-uri
        run: |
          echo "image: ${{ needs.container.outputs.IMAGE }}"

      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: Deploy via Argo to INT
        id: argo-deploy
        uses: capitec-odin/action-deploy@v7
        with:
          repository: ${{ vars.GITOPS_REPO}}
          access-token: ${{ secrets.GITOPS_TOKEN }}
          component: ${{ vars.GITOPS_COMPONENT_NAME }}
          image: '${{ needs.container.outputs.IMAGE }}'
          org: ${{ vars.GITOPS_ORG }}
          enviro: int
          jf-access-user: ${{vars.JF_ACCESS_USER}}          
          jf-access-token: ${{secrets.JF_ACCESS_TOKEN}}
          jf-project-key: ${{vars.JF_PROJECT_KEY}}

      # - name: Install JFrog
      #   id: install-jfrog
      #   uses: jfrog/setup-jfrog-cli@v3
      #   env:
      #     JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
      #     # with:
      #     #   version: latest
      #     #   download-repository: odin-jfrog-cli-remote
      # - name: Ping JFrog
      #   run: jf rt ping

      # # - name: JFrog Promote to INT
      # #   id: promote
      # #   run: jf rt build-promote $BUILD_NAME $RUN $DOCKER_REPO --project $JF_PROJECT_KEY --status INT

  # version-check:
  #   name: Version Check
  #   runs-on:
  #     - ubuntu-22.04
  #   environment: release
  #   if: ${{ github.ref_name == 'release' }}
  #   outputs:
  #     POM_UPDATE: ${{ steps.snapshot_check.outputs.POM_UPDATE }}
  #     POM_VERSION: ${{ steps.variables.outputs.POM_VERSION }}
  #   steps:
  #     - name: POM snapshot check
  #       id: snapshot_check
  #       run: |
  #         "POM_VERSION=$(mvn -Dexec.executable='echo' -Dexec.args='${project.version}' --non-recursive exec:exec -q)"
  #         echo "POM_VERSION found: $POM_VERSION"
  #         echo
  #         if [[ "$POM_VERSION" =~ "SNAPSHOT" ]]; then
  #           echo "POM_UPDATE is true: The environment variable 'POM_VERSION' does contain the string 'SNAPSHOT'. Update required."
  #           echo "POM_UPDATE=true" >> "${GITHUB_OUTPUT}"
  #         else
  #           echo "POM_UPDATE is false: The environment variable 'POM_VERSION' does not contain the string 'SNAPSHOT'. No update required."
  #           echo "POM_UPDATE=false" >> "${GITHUB_OUTPUT}"
  #         fi

  #     - name: Checkout
  #       id: checkout
  #       uses: actions/checkout@v3
  #       if: ${{ needs.version-check.outputs.POM_UPDATE == false && github.ref_name == 'release' }}

  #     - name: Update
  #       id: update
  #       run: |
  #         echo "Removing the string 'SNAPSHOT' from the POM file."
  #         mvn build-helper:parse-version versions:set -DnewVersion=\${parsedVersion.majorVersion}.\${parsedVersion.minorVersion}.\${parsedVersion.incrementalVersion} versions:commit
  #         echo "POM Version is now: $(mvn -Dexec.executable='echo' -Dexec.args='${project.version}' --non-recursive exec:exec -q)"
  #         if: ${{ needs.version-check.outputs.POM_UPDATE == false && github.ref_name == 'release' }}

  #     # - name: Commit & Push changes
  #     #   uses: actions-js/push@master
  #     #   with:
  #     #     github_token: ${{ secrets.GITHUB_TOKEN }}
  #     #   if: ${{ needs.version-check.outputs.POM_UPDATE == false && github.ref_name == 'release' }}

  create-release:
    name: Create Release
    runs-on:
      - ubuntu-22.04
    if: ${{ github.event.pull_request.merged == true && github.ref_name == 'release' }}
    needs:
      - build
      - container
    env:
      POM_ARTIFACT_ID: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
      POM_VERSION: ${{ needs.build.outputs.POM_VERSION }}
      IMAGE: ${{ needs.container.outputs.IMAGE }}
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: Create GitHub Release
        id: gh-release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release create $POM_VERSION --target release --prerelease --generate-notes
          BODY=$(gh release view $POM_VERSION --json body --jq '.body')
          echo "$BODY" >> release-notes.md
          echo "" >> release-notes.md
          echo "**Docker Image**:   ${IMAGE}" >> release-notes.md
          gh release edit $POM_VERSION --notes-file release-notes.md

  deploy-qa:
    name: Update QA deployment version
    needs:
      - build
      - container
      - create-release
    runs-on:
      - ubuntu-22.04
    if: ${{ github.event.pull_request.merged == true && github.ref_name == 'release' }}
    environment: qa
    env:
      POM_VERSION: ${{ needs.build.outputs.POM_VERSION }}
      POM_ARTIFACT_ID: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
      BUILD_NAME: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
    steps:
      - name: Print Docker Image URI
        id: docker-image-uri
        run: |
          echo "image: ${{ needs.container.outputs.IMAGE }}"

      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: Deploy via Argo to QA
        id: deploy
        uses: capitec-odin/action-deploy@v7
        with:
          repository: ${{ vars.GITOPS_REPO}}
          access-token: ${{ secrets.GITOPS_TOKEN }}
          component: ${{ vars.GITOPS_COMPONENT_NAME }}
          image: '${{ needs.container.outputs.IMAGE }}'
          org: ${{ vars.GITOPS_ORG }}
          enviro: qa
          jf-access-user: ${{vars.JF_ACCESS_USER}}          
          jf-access-token: ${{secrets.JF_ACCESS_TOKEN}}
          jf-project-key: ${{vars.JF_PROJECT_KEY}}
          
      # - name: Install JFrog
      #   id: install-jfrog
      #   uses: jfrog/setup-jfrog-cli@v3
      #   env:
      #     JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
      #     # with:
      #     #   version: latest
      #     #   download-repository: odin-jfrog-cli-remote
      # - name: Ping JFrog
      #   run: jf rt ping

      # # - name: Promote JFrog Build to QA
      # #   id: promote
      # #   run: jf rt build-promote $BUILD_NAME $RUN $DOCKER_REPO --project $JF_PROJECT_KEY --status QA

  deploy-prod:
    name: Update PROD deployment version
    needs:
      - build
      - container
      - create-release
      - deploy-qa
    runs-on:
      - ubuntu-22.04
    if: ${{ github.event.pull_request.merged == true && github.ref_name == 'release' }}
    environment: prod
    env:
      POM_VERSION: ${{ needs.build.outputs.POM_VERSION }}
      POM_ARTIFACT_ID: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
      BUILD_NAME: ${{ needs.build.outputs.POM_ARTIFACT_ID }}
    steps:
      - name: Print Docker Image URI
        id: docker-image-uri
        run: |
          echo "Image: ${{ needs.container.outputs.IMAGE }}"

      - name: Checkout
        id: checkout
        uses: actions/checkout@v3

      - name: Deploy via Argo to Prod
        id: deploy
        uses: capitec-odin/action-deploy@v7
        with:
          repository: ${{ vars.GITOPS_REPO}}
          access-token: ${{ secrets.GITOPS_TOKEN }}
          component: ${{ vars.GITOPS_COMPONENT_NAME }}
          image: '${{ needs.container.outputs.IMAGE }}'
          org: ${{ vars.GITOPS_ORG }}
          enviro: prd
          jf-access-user: ${{vars.JF_ACCESS_USER}}          
          jf-access-token: ${{secrets.JF_ACCESS_TOKEN}}
          jf-project-key: ${{vars.JF_PROJECT_KEY}}

      # - name: Install JFrog
      #   id: install-jfrog
      #   uses: jfrog/setup-jfrog-cli@v3
      #   env:
      #     JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
      #     # with:
      #     #   version: latest
      #     #   download-repository: odin-jfrog-cli-remote
      # - name: Ping JFrog
      #   run: jf rt ping

      # # - name: Promote JFrog Build to Prod
      # #   id: promote
      # #   run: jf rt build-promote $BUILD_NAME $RUN $DOCKER_REPO --project $JF_PROJECT_KEY --status PROD
